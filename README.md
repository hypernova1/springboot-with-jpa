# 실전! 스프링 부트와 JPA 활용 2

## API 데이터를 운반할땐 `Entity`가 아닌 `Dto`를 사용
### `Entity` 와 *API 스펙*의 분리 (Side Effect 방지)
* API 요청시 해당 스펙을 정확히 알 수 있음
* `Entity` 를 요청을 받을 때 사용하게 되면 API 각각의 스펙을 정확하게 알기 힘듬
* 각 API마다 유효성 검증을 다르게 할 수 있음
* `Entity` 전부를 노출시키지 않고 필요한 프로퍼티만 노출
---

## 쿼리를 위한 함수와 조회를 위한 함수를 따로 사용
* 업데이트 함수(id값 반환까지는 OK)와 조회함수를 따로 두고 사용하면 유지보수가 용이해진다
---

## `@FetchType`을 `Lazy`로 설정하게 되면 해당 객체를 프록시 객체로 감싸서 넣어 두고 가져다 쓸때 DB에 요청을 함
---

## `Entity`와 연관 관계를 맺고 있는 `Entity`가 있다면 조회했을 때 N + 1의 문제가 발생
* Member 엔티티 안에 Address 엔티티가 있고 Member를 2개 이상 조회해 왔을 때  
* `stream`을 돌려고 한다면 Member 객체가 바뀔 때마다 Adress 를 조회함  
* 1(전체 Member 조회) + N(Member의 수만큼 Address 조회)  
* 연관 관계를 맺고 있는 엔티티가 많을 수록 엄청나게 증가함  
*  => **Fetch Join(JPQL)을 이용하여 한 방에 가져오자**
---